/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if ((from && typeof from === "object") || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, {
          get: () => from[key],
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
        });
  }
  return to;
};
var __toCommonJS = (mod) =>
  __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HabitGridPlugin,
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/types/index.ts
var DEFAULT_SETTINGS = {
  configFilePath: "",
  weekStartsOn: "monday",
  showStats: true,
  gridCellSize: 11,
  gridGap: 3,
  defaultColors: ["#ebedf0", "#9be9a8", "#40c463", "#30a14e", "#216e39"],
  openOnStartup: false,
  bannerImagePath: "",
};

// src/utils/dateUtils.ts
function parseDateFromDMY(dateStr) {
  const match = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
  if (!match) return null;
  const day = match[1].padStart(2, "0");
  const month = match[2].padStart(2, "0");
  const year = match[3];
  return `${year}-${month}-${day}`;
}
function parseISODate(dateStr) {
  const [year, month, day] = dateStr.split("-").map(Number);
  return new Date(year, month - 1, day);
}
function getDayOfWeekMondayStart(date) {
  const day = date.getDay();
  return day === 0 ? 6 : day - 1;
}
function getMonthName(month) {
  const months = [
    "Ene",
    "Feb",
    "Mar",
    "Abr",
    "May",
    "Jun",
    "Jul",
    "Ago",
    "Sep",
    "Oct",
    "Nov",
    "Dic",
  ];
  return months[month];
}
function formatDateForDisplay(dateStr) {
  const date = parseISODate(dateStr);
  const options = {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric",
  };
  return date.toLocaleDateString("es-ES", options);
}

function updateCardHeight(card) {
  const inner = card.querySelector(".habit-card-flip-inner");
  const front = card.querySelector(".habit-card-front");
  const back = card.querySelector(".habit-card-back");

  const frontHeight = front.offsetHeight;
  const backHeight = back.offsetHeight;

  const targetHeight = card.classList.contains("flipped")
    ? backHeight
    : frontHeight;

  card.style.height = `${targetHeight}px`;
}

// src/parser/habitParser.ts
var HabitParser = class {
  /**
   * Parsea el contenido completo del archivo
   */
  parseFile(content, filePath) {
    const habits = this.parseHabitDefinitions(content);
    const todoEntries = this.parseTodoList(content);
    const year = this.detectYear(todoEntries);
    console.log("Habits encontrados:", habits.length);
    console.log("Entradas TODO encontradas:", todoEntries.size);
    return {
      year,
      habits,
      todoEntries,
      sourceFile: filePath,
    };
  }
  /**
   * Extrae las definiciones de h√°bitos del contenido
   */
  parseHabitDefinitions(content) {
    const habits = [];
    const habitBlockRegex = /```habit-definition\s*\n([\s\S]*?)```/g;
    let match;
    while ((match = habitBlockRegex.exec(content)) !== null) {
      const blockContent = match[1];
      const habit = this.parseHabitBlock(blockContent);
      if (habit) {
        habits.push(habit);
      }
    }
    return habits;
  }
  /**
   * Parsea un bloque individual de definici√≥n de h√°bito
   */
  parseHabitBlock(block) {
    const lines = block.trim().split("\n");
    const habit = {};
    for (const line of lines) {
      const colonIndex = line.indexOf(":");
      if (colonIndex === -1) continue;
      const key = line.substring(0, colonIndex).trim().toLowerCase();
      let value = line.substring(colonIndex + 1).trim();
      switch (key) {
        case "tema":
          habit.tema = value;
          break;
        case "emoji":
          habit.emoji = value;
          break;
        case "colors":
          habit.colors = this.parseColorArray(value);
          break;
        case "meta_semanal":
        case "metasemanal":
          habit.metaSemanal = parseInt(value, 10);
          break;
        case "descripcion":
          habit.descripcion = value;
          break;
        case "grupo":
          habit.grupo = value;
          break;
      }
    }
    if (!habit.tema) {
      return null;
    }
    if (!habit.colors || habit.colors.length === 0) {
      habit.colors = ["#ebedf0", "#9be9a8", "#40c463", "#30a14e", "#216e39"];
    }
    return habit;
  }
  /**
   * Parsea un array de colores desde string
   */
  parseColorArray(value) {
    try {
      const parsed = JSON.parse(value.replace(/'/g, '"'));
      if (Array.isArray(parsed)) {
        return parsed;
      }
    } catch (e) {
      const colors = value
        .replace(/[\[\]]/g, "")
        .split(",")
        .map((c) => c.trim().replace(/['"]/g, ""))
        .filter((c) => c.length > 0);
      if (colors.length > 0) {
        return colors;
      }
    }
    return [];
  }
  /**
   * Parsea la secci√≥n TODO list - l√≠nea por l√≠nea para mayor robustez
   */
  parseTodoList(content) {
    const entries = /* @__PURE__ */ new Map();
    const lines = content.split("\n");
    let currentDate = null;
    let currentEntries = null;
    let inTodoSection = false;
    for (const line of lines) {
      const trimmedLine = line.trim();
      if (trimmedLine.match(/^#\s+TODO\s*list/i)) {
        inTodoSection = true;
        continue;
      }
      if (
        inTodoSection &&
        trimmedLine.match(/^#\s+[^#]/) &&
        !trimmedLine.match(/^#\s+TODO/i)
      ) {
        if (currentDate && currentEntries && currentEntries.size > 0) {
          entries.set(currentDate, currentEntries);
        }
        break;
      }
      if (!inTodoSection) continue;
      const dateMatch = trimmedLine.match(/^##\s*(\d{1,2}\/\d{1,2}\/\d{4})/);
      if (dateMatch) {
        if (currentDate && currentEntries && currentEntries.size > 0) {
          entries.set(currentDate, currentEntries);
        }
        const isoDate = parseDateFromDMY(dateMatch[1]);
        if (isoDate) {
          currentDate = isoDate;
          currentEntries = /* @__PURE__ */ new Map();
        }
        continue;
      }
      const checkboxMatch = trimmedLine.match(/^-\s*\[([ xX])\]\s*(.+)/);
      if (checkboxMatch && currentDate && currentEntries) {
        const isChecked = checkboxMatch[1].toLowerCase() === "x";
        const habitName = checkboxMatch[2].trim().toLowerCase();
        currentEntries.set(habitName, isChecked);
      }
    }
    if (currentDate && currentEntries && currentEntries.size > 0) {
      entries.set(currentDate, currentEntries);
    }
    console.log("Fechas parseadas:", Array.from(entries.keys()));
    return entries;
  }
  /**
   * Detecta el a√±o bas√°ndose en las entradas
   */
  detectYear(entries) {
    for (const dateStr of entries.keys()) {
      const year = parseInt(dateStr.substring(0, 4), 10);
      if (!isNaN(year)) {
        return year;
      }
    }
    return new Date().getFullYear();
  }
};

// src/views/HabitGridView.ts
var import_obsidian = require("obsidian");
var HABIT_GRID_VIEW_TYPE = "habit-grid-view";
var HabitGridView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.config = null;
    this.tooltip = null;
    this.plugin = plugin;
    this.chartCanvas = null;
    this.chartContainer = null;
    this.chartData = null;
    this.chartDays = null;
    this.resizeObserver = null;
  }

  getViewType() {
    return HABIT_GRID_VIEW_TYPE;
  }
  getDisplayText() {
    return "Habit Grid Tracker";
  }
  getIcon() {
    return "calendar-check";
  }
  async onOpen() {
    await this.loadAndRender();
  }
  async onClose() {
    this.contentEl.empty();
    if (this.tooltip) {
      this.tooltip.remove();
    }
  }
  /**
   * Carga los datos y renderiza la vista
   */
  async loadAndRender() {
    const container = this.contentEl;
    container.empty();
    container.addClass("habit-grid-container");
    this.createTooltip(container);
    if (!this.plugin.settings.configFilePath) {
      this.renderNoConfig(container);
      return;
    }
    const file = this.app.vault.getAbstractFileByPath(
      this.plugin.settings.configFilePath,
    );
    if (!file || !(file instanceof import_obsidian.TFile)) {
      this.renderFileNotFound(container);
      return;
    }
    try {
      const content = await this.app.vault.read(file);
      this.config = this.plugin.parser.parseFile(content, file.path);
      this.renderView(container);
    } catch (error) {
      this.renderError(container, error);
    }
  }

  createTooltip(container) {
    // CAMBIO: Lo creamos en el body, no en el container, para que las coordenadas sean exactas
    this.tooltip = document.body.createDiv({ cls: "grid-tooltip" });
    this.tooltip.createDiv({ cls: "grid-tooltip-date" });
    this.tooltip.createDiv({ cls: "grid-tooltip-status" });
  }
  /**
   * Muestra el tooltip
   */
  showTooltip(event, date, isCompleted) {
    if (!this.tooltip) return;
    const dateEl = this.tooltip.querySelector(".grid-tooltip-date");
    const statusEl = this.tooltip.querySelector(".grid-tooltip-status");
    dateEl.textContent = formatDateForDisplay(date);
    statusEl.textContent = isCompleted
      ? "\u2713 Completado"
      : "\u2717 No completado";
    statusEl.className = `grid-tooltip-status ${isCompleted ? "completed" : ""}`;
    const rect = event.target.getBoundingClientRect();
    this.tooltip.style.left = `${rect.left + rect.width / 2}px`;
    this.tooltip.style.top = `${rect.top - 8}px`;
    this.tooltip.style.transform = "translate(-50%, -100%)";
    this.tooltip.addClass("visible");
  }
  /**
   * Oculta el tooltip
   */
  hideTooltip() {
    if (this.tooltip) {
      this.tooltip.removeClass("visible");
    }
  }
  /**
   * Renderiza la vista principal
   */
  renderView(container) {
    if (!this.config) return;
    const hasBanner = this.renderBanner(container);
    const contentContainer = container.createDiv({ cls: "habit-grid-content" });
    if (!hasBanner) {
      contentContainer.style.marginTop = "0";
      contentContainer.style.padding = "24px";
    }
    this.renderStatsOverview(contentContainer);
    const gridsContainer = contentContainer.createDiv({
      cls: "habit-grids-wrapper",
    });
    for (const habit of this.config.habits) {
      this.renderHabitGrid(gridsContainer, habit);
    }
  }
  /**
   * Renderiza el banner o header
   * @returns true si se renderiz√≥ un banner, false si no
   */
  renderBanner(container) {
    const bannerPath = this.plugin.settings.bannerImagePath;
    if (bannerPath) {
      const file = this.app.vault.getAbstractFileByPath(bannerPath);
      if (file && file instanceof import_obsidian.TFile) {
        const bannerContainer = container.createDiv({
          cls: "habit-grid-banner",
        });
        const img = bannerContainer.createEl("img");
        img.src = this.app.vault.getResourcePath(file);
        img.alt = "Banner";
        const overlay = bannerContainer.createDiv({
          cls: "habit-grid-banner-overlay",
        });
        overlay.createEl("h1", {
          text: "Grid Tracker",
          cls: "habit-grid-banner-title",
        });
        return true;
      }
    }
    this.renderHeader(container);
    return false;
  }
  /**
   * Renderiza el header normal (sin banner)
   */
  renderHeader(container) {
    var _a;
    const header = container.createDiv({ cls: "habit-grid-header" });
    const titleWrapper = header.createDiv({ cls: "habit-grid-title-wrapper" });
    titleWrapper.createEl("h1", {
      text: "LDR | Habit Grid Tracker",
      cls: "habit-grid-title",
    });
    const yearBadge = header.createDiv({ cls: "habit-grid-year" });
    yearBadge.setText(
      String(
        ((_a = this.config) == null ? void 0 : _a.year) ||
          new Date().getFullYear(),
      ),
    );
  }
  /**
   * Renderiza la secci√≥n de estad√≠sticas generales con gr√°fica
   */
  renderStatsOverview(container) {
    if (!this.config || this.config.habits.length === 0) return;
    const overviewCard = container.createDiv({ cls: "habit-stats-overview" });
    const header = overviewCard.createDiv({
      cls: "habit-stats-overview-header",
    });
    header.createEl("h3", {
      text: "Resumen de Progreso",
      cls: "habit-stats-overview-title",
    });
    header.createSpan({
      text: "\xDAltimos 30 d\xEDas",
      cls: "habit-stats-overview-period",
    });
    const chartContainer = overviewCard.createDiv({
      cls: "habit-chart-container",
    });
    this.chartContainer = chartContainer;
    this.renderChart(chartContainer);
    const legend = overviewCard.createDiv({ cls: "habit-chart-legend" });
    for (const habit of this.config.habits) {
      const legendItem = legend.createDiv({ cls: "habit-chart-legend-item" });
      const dot = legendItem.createDiv({ cls: "habit-chart-legend-dot" });
      dot.style.backgroundColor =
        habit.colors[Math.min(2, habit.colors.length - 1)];
      legendItem.createSpan({ text: habit.tema });
    }
  }
  /**
   * Renderiza el gr√°fico de l√≠neas
   */
  renderChart(container) {
    if (!this.config) return;
    const canvas = container.createEl("canvas", { cls: "habit-chart-canvas" });
    this.chartCanvas = canvas;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    const rect = container.getBoundingClientRect();
    const width = rect.width || 800;
    const height = 120;
    const dpr = window.devicePixelRatio || 1;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    ctx.scale(dpr, dpr);
    const today = new Date();
    const days = [];
    for (let i = 29; i >= 0; i--) {
      const date = new Date(today);
      date.setDate(date.getDate() - i);
      const yyyy = date.getFullYear();
      const mm = String(date.getMonth() + 1).padStart(2, "0");
      const dd = String(date.getDate()).padStart(2, "0");
      days.push(`${yyyy}-${mm}-${dd}`);
    }
    this.chartDays = days;
    const habitData = /* @__PURE__ */ new Map();
    for (const habit of this.config.habits) {
      const data = [];
      let cumulative = 0;
      for (const day of days) {
        if (this.isDayCompleted(day, habit.tema)) {
          cumulative++;
        }
        data.push(cumulative);
      }
      habitData.set(habit.tema, data);
    }
    this.chartData = habitData;
    const padding = { top: 10, right: 10, bottom: 20, left: 30 };
    const chartWidth = width - padding.left - padding.right;
    const chartHeight = height - padding.top - padding.bottom;
    let maxValue = 1;
    for (const data of habitData.values()) {
      maxValue = Math.max(maxValue, ...data);
    }
    ctx.strokeStyle = "rgba(255,255,255,0.1)";
    ctx.lineWidth = 1;
    for (let i = 0; i <= 4; i++) {
      const y = padding.top + (chartHeight / 4) * i;
      ctx.beginPath();
      ctx.moveTo(padding.left, y);
      ctx.lineTo(width - padding.right, y);
      ctx.stroke();
    }
    let habitIndex = 0;
    for (const habit of this.config.habits) {
      const data = habitData.get(habit.tema);
      if (!data) continue;
      const color = habit.colors[Math.min(2, habit.colors.length - 1)];
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < data.length; i++) {
        const x = padding.left + (i / (data.length - 1)) * chartWidth;
        const y =
          padding.top + chartHeight - (data[i] / maxValue) * chartHeight;
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();
      const lastX = padding.left + chartWidth;
      const lastY =
        padding.top +
        chartHeight -
        (data[data.length - 1] / maxValue) * chartHeight;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(lastX, lastY, 4, 0, Math.PI * 2);
      ctx.fill();
      habitIndex++;
    }
    ctx.fillStyle = "rgba(255,255,255,0.5)";
    ctx.font = "10px sans-serif";
    ctx.textAlign = "center";
    const labelIndices = [0, 9, 19, 29];
    for (const i of labelIndices) {
      if (i < days.length) {
        const x = padding.left + (i / (days.length - 1)) * chartWidth;
        const date = new Date(days[i]);
        const label = `${date.getDate()}/${date.getMonth() + 1}`;
        ctx.fillText(label, x, height - 5);
      }
    }

    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }
    this.resizeObserver = new ResizeObserver(() => {
      this.redrawChart();
    });
    this.resizeObserver.observe(container);

    canvas.addEventListener("mousemove", (e) => {
      this.handleChartHover(e);
    });
    canvas.addEventListener("mouseleave", () => {
      this.hideTooltip();
    });
  }

  /**
   * Redibuja el gr√°fico cuando cambia el tama√±o
   */
  redrawChart() {
    if (
      !this.chartCanvas ||
      !this.chartContainer ||
      !this.chartData ||
      !this.chartDays ||
      !this.config
    ) {
      return;
    }
    const canvas = this.chartCanvas;
    const container = this.chartContainer;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    const rect = container.getBoundingClientRect();
    const width = rect.width || 800;
    const height = 120;
    const dpr = window.devicePixelRatio || 1;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, width, height);
    const days = this.chartDays;
    const habitData = this.chartData;
    const padding = { top: 10, right: 10, bottom: 20, left: 30 };
    const chartWidth = width - padding.left - padding.right;
    const chartHeight = height - padding.top - padding.bottom;
    let maxValue = 1;
    for (const data of habitData.values()) {
      maxValue = Math.max(maxValue, ...data);
    }
    ctx.strokeStyle = "rgba(255,255,255,0.1)";
    ctx.lineWidth = 1;
    for (let i = 0; i <= 4; i++) {
      const y = padding.top + (chartHeight / 4) * i;
      ctx.beginPath();
      ctx.moveTo(padding.left, y);
      ctx.lineTo(width - padding.right, y);
      ctx.stroke();
    }
    for (const habit of this.config.habits) {
      const data = habitData.get(habit.tema);
      if (!data) continue;
      const color = habit.colors[Math.min(2, habit.colors.length - 1)];
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < data.length; i++) {
        const x = padding.left + (i / (data.length - 1)) * chartWidth;
        const y =
          padding.top + chartHeight - (data[i] / maxValue) * chartHeight;
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.stroke();
      const lastX = padding.left + chartWidth;
      const lastY =
        padding.top +
        chartHeight -
        (data[data.length - 1] / maxValue) * chartHeight;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(lastX, lastY, 4, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.fillStyle = "rgba(255,255,255,0.5)";
    ctx.font = "10px sans-serif";
    ctx.textAlign = "center";
    const labelIndices = [0, 9, 19, 29];
    for (const i of labelIndices) {
      if (i < days.length) {
        const x = padding.left + (i / (days.length - 1)) * chartWidth;
        const date = new Date(days[i]);
        const label = `${date.getDate()}/${date.getMonth() + 1}`;
        ctx.fillText(label, x, height - 5);
      }
    }
  }

  /**
   * Maneja el hover sobre el gr√°fico
   */
  handleChartHover(e) {
    if (
      !this.chartCanvas ||
      !this.chartData ||
      !this.chartDays ||
      !this.config
    ) {
      return;
    }
    const canvas = this.chartCanvas;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const width = rect.width;
    const relativeX = x / width;
    const dayIndex = Math.floor(relativeX * 30);

    if (dayIndex >= 0 && dayIndex < 30 && dayIndex < this.chartDays.length) {
      const dateStr = this.chartDays[dayIndex];
      let tooltipText = "";
      let hasData = false;

      for (const habit of this.config.habits) {
        const data = this.chartData.get(habit.tema);
        if (data && data[dayIndex] !== undefined) {
          tooltipText += `${habit.tema}: ${data[dayIndex]} d√≠as\n`;
          hasData = true;
        }
      }

      if (hasData && this.tooltip) {
        const dateEl = this.tooltip.querySelector(".grid-tooltip-date");
        const statusEl = this.tooltip.querySelector(".grid-tooltip-status");

        if (dateEl && statusEl) {
          const date = new Date(dateStr);
          dateEl.textContent = date.toLocaleDateString("es-ES", {
            weekday: "long",
            month: "long",
            day: "numeric",
          });
          statusEl.textContent = tooltipText.trim().replace(/\n/g, " ‚Ä¢ ");
          statusEl.className = "grid-tooltip-status";

          this.tooltip.style.left = `${e.clientX}px`;
          this.tooltip.style.top = `${e.clientY - 50}px`;
          this.tooltip.style.transform = "translate(-50%, 0)";
          this.tooltip.addClass("visible");
        }
      }
    }
  }

  renderHabitGrid(container, habit) {
    if (!this.config) return;
    const card = container.createDiv({ cls: "habit-card" });

    // Agregar atributo tabindex para accesibilidad
    card.setAttribute("tabindex", "0");

    // Crear estructura flip con dos caras
    const flipInner = card.createDiv({ cls: "habit-card-flip-inner" });
    const cardFront = flipInner.createDiv({ cls: "habit-card-front" });
    const cardBack = flipInner.createDiv({ cls: "habit-card-back" });

    // ===== CARA FRONTAL (contenido existente) =====
    const cardHeader = cardFront.createDiv({ cls: "habit-card-header" });
    const nameWrapper = cardHeader.createDiv({ cls: "habit-name" });
    if (habit.emoji) {
      const iconContainer = nameWrapper.createDiv({ cls: "habit-icon" });
      if (
        habit.emoji.startsWith("http") ||
        habit.emoji.startsWith("/") ||
        habit.emoji.includes(".")
      ) {
        const img = iconContainer.createEl("img");
        if (!habit.emoji.startsWith("http")) {
          const iconFile = this.app.vault.getAbstractFileByPath(habit.emoji);
          if (iconFile && iconFile instanceof import_obsidian.TFile) {
            img.src = this.app.vault.getResourcePath(iconFile);
          } else {
            img.src = habit.emoji;
          }
        } else {
          img.src = habit.emoji;
        }
        img.alt = habit.tema;
      } else {
        iconContainer.setText(habit.emoji);
      }
    }
    nameWrapper.createSpan({ text: habit.tema, cls: "habit-tema" });
    const stats = this.calculateStats(habit);
    const streakBadge = cardHeader.createDiv({ cls: "habit-streak" });
    streakBadge.setText(`Racha actual: ${stats.currentStreak} d√≠as`);
    const gridWrapper = cardFront.createDiv({ cls: "grid-wrapper" });
    this.renderYearGrid(gridWrapper, habit);
    if (this.plugin.settings.showStats) {
      this.renderStats(cardFront, habit, stats);
    }

    // ===== CARA TRASERA (nuevo) =====
    const advancedStats = this.calculateAdvancedStats(habit, stats);
    this.renderCardBack(cardBack, habit, stats, advancedStats);

    // ===== FUNCI√ìN DE ANIMACI√ìN (DESPU√âS del renderizado) =====
    const animateCardHeight = (card, showBack) => {
      const front = card.querySelector(".habit-card-front");
      const back = card.querySelector(".habit-card-back");

      const startHeight = card.offsetHeight;
      const targetHeight = showBack ? back.scrollHeight : front.scrollHeight;

      card.style.height = `${startHeight}px`;

      requestAnimationFrame(() => {
        card.style.height = `${targetHeight}px`;
      });
    };

    // ===== EVENTOS DE FLIP (UNA SOLA VEZ) =====
    card.addEventListener("click", (e) => {
      // No voltear si se clickea una celda del grid
      if (e.target.classList.contains("grid-cell")) return;
      // No voltear si se clickea el flip button
      if (e.target.classList.contains("flip-button")) return;

      const goingToBack = !card.classList.contains("flipped");

      animateCardHeight(card, goingToBack);
      card.classList.toggle("flipped");
      updateCardHeight(card);
    });

    // Soporte de teclado (Enter o Espacio)
    card.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        card.classList.toggle("flipped");
        updateCardHeight(card);
      }
    });
  }

  /**
   * Renderiza el grid del a√±o completo
   */
  renderYearGrid(container, habit) {
    if (!this.config) return;
    const year = this.config.year;
    const weeklyIntensity = this.calculateWeeklyIntensity(habit);
    const gridContainer = container.createDiv({ cls: "year-grid" });
    const monthLabelsRow = gridContainer.createDiv({
      cls: "grid-month-labels",
    });
    monthLabelsRow.createDiv({ cls: "day-label-spacer" });
    const gridContent = gridContainer.createDiv({ cls: "grid-content" });
    const dayLabelsCol = gridContent.createDiv({ cls: "grid-day-labels" });
    const dayNames = ["Lun", "Mar", "Mi\xE9", "Jue", "Vie", "S\xE1b", "Dom"];
    dayNames.forEach((name, idx) => {
      const label = dayLabelsCol.createDiv({ cls: "day-label" });
      if (idx === 0 || idx === 2 || idx === 4 || idx === 6) {
        label.setText(name);
      }
    });
    const weeksContainer = gridContent.createDiv({ cls: "grid-weeks" });
    const weeks = this.generateWeeksForYear(year);
    let lastMonth = -1;
    weeks.forEach((week, weekIndex) => {
      const weekCol = weeksContainer.createDiv({ cls: "grid-week" });
      week.forEach((dayInfo, dayOfWeek) => {
        const cell = weekCol.createDiv({ cls: "grid-cell" });
        if (dayInfo) {
          const { dateStr, month } = dayInfo;
          if (month !== lastMonth && dayOfWeek === 0) {
            const monthLabel = monthLabelsRow.createDiv({ cls: "month-label" });
            monthLabel.setText(getMonthName(month));
            lastMonth = month;
          }
          const isCompleted = this.isDayCompleted(dateStr, habit.tema);
          let level = 0;
          if (isCompleted) {
            const weekIntensity = weeklyIntensity.get(weekIndex) || 0;
            if (weekIntensity >= 6) level = 4;
            else if (weekIntensity >= 4) level = 3;
            else if (weekIntensity >= 2) level = 2;
            else level = 1;
          }
          cell.setAttribute("data-level", String(level));
          cell.setAttribute("data-date", dateStr);
          if (isCompleted && level > 0) {
            const colorIndex = Math.min(level, habit.colors.length - 1);
            cell.style.backgroundColor = habit.colors[colorIndex];
          }
          cell.addClass("has-tooltip");
          cell.addEventListener("mouseenter", (e) => {
            this.showTooltip(e, dateStr, isCompleted);
          });
          cell.addEventListener("mouseleave", () => {
            this.hideTooltip();
          });
        } else {
          cell.addClass("empty-cell");
        }
      });
    });
  }
  /**
   * Genera las semanas del a√±o con informaci√≥n de cada d√≠a
   */
  generateWeeksForYear(year) {
    const weeks = [];
    const firstDay = new Date(year, 0, 1);
    const lastDay = new Date(year, 11, 31);
    const firstDayOfWeek = getDayOfWeekMondayStart(firstDay);
    const currentDate = new Date(firstDay);
    currentDate.setDate(currentDate.getDate() - firstDayOfWeek);
    while (currentDate <= lastDay || currentDate.getDay() !== 1) {
      const week = [];
      for (let i = 0; i < 7; i++) {
        if (currentDate.getFullYear() === year) {
          const yyyy = currentDate.getFullYear();
          const mm = String(currentDate.getMonth() + 1).padStart(2, "0");
          const dd = String(currentDate.getDate()).padStart(2, "0");
          week.push({
            dateStr: `${yyyy}-${mm}-${dd}`,
            month: currentDate.getMonth(),
          });
        } else {
          week.push(null);
        }
        currentDate.setDate(currentDate.getDate() + 1);
      }
      weeks.push(week);
      if (currentDate.getFullYear() > year) {
        break;
      }
    }
    return weeks;
  }
  /**
   * Calcula la intensidad (d√≠as completados) por semana para un h√°bito
   * Retorna un Map de weekIndex -> n√∫mero de d√≠as completados esa semana
   */
  calculateWeeklyIntensity(habit) {
    const intensity = /* @__PURE__ */ new Map();
    if (!this.config) return intensity;
    const year = this.config.year;
    const weeks = this.generateWeeksForYear(year);
    weeks.forEach((week, weekIndex) => {
      let completedDays = 0;
      for (const dayInfo of week) {
        if (dayInfo && this.isDayCompleted(dayInfo.dateStr, habit.tema)) {
          completedDays++;
        }
      }
      intensity.set(weekIndex, completedDays);
    });
    return intensity;
  }
  /**
   * Verifica si un d√≠a est√° completado para un h√°bito
   */
  isDayCompleted(dateStr, habitName) {
    if (!this.config) return false;
    const dayEntries = this.config.todoEntries.get(dateStr);
    if (!dayEntries) return false;
    const habitNameLower = habitName.toLowerCase().trim();
    for (const [key, value] of dayEntries.entries()) {
      if (key.toLowerCase().trim() === habitNameLower) {
        return value === true;
      }
    }
    return false;
  }

  /**
   * Calcula estad√≠sticas para un h√°bito
   */
  calculateStats(habit) {
    if (!this.config) {
      return { currentStreak: 0, bestStreak: 0, totalDays: 0, thisWeek: 0 };
    }
    const completedDates = [];
    for (const [dateStr, dayEntries] of this.config.todoEntries.entries()) {
      const habitNameLower = habit.tema.toLowerCase().trim();
      for (const [key, value] of dayEntries.entries()) {
        if (key.toLowerCase().trim() === habitNameLower && value === true) {
          completedDates.push(dateStr);
        }
      }
    }
    completedDates.sort();
    console.log(
      `Stats para ${habit.tema}: ${completedDates.length} d\xEDas completados`,
      completedDates.slice(0, 5),
    );
    if (completedDates.length === 0) {
      return { currentStreak: 0, bestStreak: 0, totalDays: 0, thisWeek: 0 };
    }
    const totalDays = completedDates.length;
    let currentStreak = 0;
    let bestStreak = 0;
    let tempStreak = 1;
    for (let i = 1; i < completedDates.length; i++) {
      const prevDate = new Date(completedDates[i - 1]);
      const currDate = new Date(completedDates[i]);
      const diffDays = Math.round(
        (currDate.getTime() - prevDate.getTime()) / (1e3 * 60 * 60 * 24),
      );
      if (diffDays === 1) {
        tempStreak++;
      } else {
        if (tempStreak > bestStreak) {
          bestStreak = tempStreak;
        }
        tempStreak = 1;
      }
    }
    if (tempStreak > bestStreak) {
      bestStreak = tempStreak;
    }
    const lastCompletedDate = new Date(
      completedDates[completedDates.length - 1],
    );
    const today = new Date();
    const daysSinceLastCompleted = Math.round(
      (today.getTime() - lastCompletedDate.getTime()) / (1e3 * 60 * 60 * 24),
    );
    if (daysSinceLastCompleted <= 1) {
      currentStreak = tempStreak;
    } else {
      currentStreak = 0;
    }
    let thisWeek = 0;
    const now = new Date();
    const startOfWeek = new Date(now);
    const dayOfWeek = now.getDay();
    const daysToSubtract = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
    startOfWeek.setDate(now.getDate() - daysToSubtract);
    startOfWeek.setHours(0, 0, 0, 0);
    for (const dateStr of completedDates) {
      const date = new Date(dateStr);
      if (date >= startOfWeek && date <= now) {
        thisWeek++;
      }
    }
    console.log(
      `Stats ${habit.tema}: total=${totalDays}, currentStreak=${currentStreak}, bestStreak=${bestStreak}, thisWeek=${thisWeek}`,
    );
    return { currentStreak, bestStreak, totalDays, thisWeek };
  }
  /**
   * Calcula estad√≠sticas avanzadas para el reverso
   */
  calculateAdvancedStats(habit, basicStats) {
    if (!this.config) {
      return null;
    }

    // Calcular √©xito mensual
    const now = new Date();
    const currentMonth = now.getMonth();
    const currentYear = now.getFullYear();

    let daysInMonth = 0;
    let completedInMonth = 0;

    for (const [dateStr, dayEntries] of this.config.todoEntries.entries()) {
      const date = new Date(dateStr);
      if (
        date.getMonth() === currentMonth &&
        date.getFullYear() === currentYear
      ) {
        daysInMonth++;
        const habitNameLower = habit.tema.toLowerCase().trim();
        for (const [key, value] of dayEntries.entries()) {
          if (key.toLowerCase().trim() === habitNameLower && value === true) {
            completedInMonth++;
            break;
          }
        }
      }
    }

    const monthSuccess =
      daysInMonth > 0 ? Math.round((completedInMonth / daysInMonth) * 100) : 0;

    // Calcular d√≠a m√°s productivo
    const dayStats = new Map(); // 0=Lun, 1=Mar, ..., 6=Dom
    for (let i = 0; i < 7; i++) {
      dayStats.set(i, { completed: 0, total: 0 });
    }

    for (const [dateStr, dayEntries] of this.config.todoEntries.entries()) {
      const date = new Date(dateStr);
      const dayOfWeek = (date.getDay() + 6) % 7; // Convertir a Lun=0
      const stats = dayStats.get(dayOfWeek);
      stats.total++;

      const habitNameLower = habit.tema.toLowerCase().trim();
      for (const [key, value] of dayEntries.entries()) {
        if (key.toLowerCase().trim() === habitNameLower && value === true) {
          stats.completed++;
          break;
        }
      }
    }

    // Encontrar el d√≠a con mejor porcentaje
    let topDay = 0;
    let topDayPercent = 0;
    const dayNames = [
      "Lunes",
      "Martes",
      "Mi√©rcoles",
      "Jueves",
      "Viernes",
      "S√°bado",
      "Domingo",
    ];

    for (const [day, stats] of dayStats.entries()) {
      if (stats.total > 0) {
        const percent = Math.round((stats.completed / stats.total) * 100);
        if (percent > topDayPercent) {
          topDayPercent = percent;
          topDay = day;
        }
      }
    }

    // Calcular tendencia (comparar √∫ltimas 2 semanas vs 2 anteriores)
    const twoWeeksAgo = new Date(now);
    twoWeeksAgo.setDate(now.getDate() - 14);

    const fourWeeksAgo = new Date(now);
    fourWeeksAgo.setDate(now.getDate() - 28);

    let recentCompleted = 0;
    let previousCompleted = 0;

    for (const [dateStr, dayEntries] of this.config.todoEntries.entries()) {
      const date = new Date(dateStr);
      const habitNameLower = habit.tema.toLowerCase().trim();
      let isCompleted = false;

      for (const [key, value] of dayEntries.entries()) {
        if (key.toLowerCase().trim() === habitNameLower && value === true) {
          isCompleted = true;
          break;
        }
      }

      if (isCompleted) {
        if (date >= twoWeeksAgo && date <= now) {
          recentCompleted++;
        } else if (date >= fourWeeksAgo && date < twoWeeksAgo) {
          previousCompleted++;
        }
      }
    }

    let trend = "stable";
    if (recentCompleted > previousCompleted + 2) trend = "up";
    else if (recentCompleted < previousCompleted - 2) trend = "down";

    // Calcular XP y nivel
    const xpData = this.calculateXPAndLevel(
      basicStats.totalDays,
      basicStats.currentStreak,
      basicStats.bestStreak,
    );

    // Verificar badges
    const badges = this.checkBadges(habit, basicStats, monthSuccess);

    return {
      monthSuccess,
      topDay: dayNames[topDay],
      topDayPercent,
      dayStats,
      trend,
      ...xpData,
      badges,
    };
  }
  /**
   * Calcula XP y nivel basado en logros
   */
  calculateXPAndLevel(totalDays, currentStreak, bestStreak) {
    // Sistema de XP
    let xp = 0;

    // XP base por d√≠as completados
    xp += totalDays * 10;

    // Bonus por racha actual
    if (currentStreak >= 7) xp += 50;
    if (currentStreak >= 14) xp += 100;
    if (currentStreak >= 30) xp += 200;

    // Bonus por mejor racha
    if (bestStreak >= 7) xp += 30;
    if (bestStreak >= 14) xp += 60;
    if (bestStreak >= 30) xp += 150;

    // Sistema de niveles
    const levels = [
      { min: 0, max: 100, name: "Novato", icon: "icons/sprout.svg" },
      { min: 100, max: 250, name: "Aprendiz", icon: "icons/book-marked.svg" },
      {
        min: 250,
        max: 500,
        name: "Practicante",
        icon: "icons/biceps-flexed.svg",
      },
      { min: 500, max: 1000, name: "Experto", icon: "icons/target-arrow.svg" },
      { min: 1000, max: 2000, name: "Maestro", icon: "icons/star.svg" },
      { min: 2000, max: 5000, name: "Leyenda", icon: "icons/chess-queen.svg" },
      { min: 5000, max: Infinity, name: "Inmortal", icon: "icons/gem.svg" },
    ];

    let level = 1;
    let levelName = "Novato";
    let levelIcon = "üå±";
    let xpForNext = 100;

    for (let i = 0; i < levels.length; i++) {
      if (xp >= levels[i].min && xp < levels[i].max) {
        level = i + 1;
        levelName = levels[i].name;
        levelIcon = levels[i].icon;
        xpForNext = levels[i].max;
        break;
      }
    }

    const xpInCurrentLevel = xp - levels[level - 1].min;
    const xpNeededForLevel = xpForNext - levels[level - 1].min;
    const percentToNext = Math.round(
      (xpInCurrentLevel / xpNeededForLevel) * 100,
    );

    return {
      xp,
      level,
      levelName,
      levelIcon,
      xpForNext,
      xpInCurrentLevel,
      xpNeededForLevel,
      percentToNext,
    };
  }
  /**
   * Verifica qu√© badges est√°n desbloqueados
   */
  checkBadges(habit, stats, monthSuccess) {
    const badges = [];

    // Badge: Racha de Fuego (7 d√≠as seguidos)
    if (stats.currentStreak >= 7) {
      badges.push({
        id: "fire",
        icon: "icons/flame.svg",
        name: "Racha de Fuego",
        unlocked: true,
      });
    } else {
      badges.push({
        id: "fire",
        icon: "icons/flame.svg",
        name: "Racha de Fuego",
        unlocked: false,
      });
    }

    // Badge: Diamante (30 d√≠as seguidos)
    if (stats.currentStreak >= 30) {
      badges.push({
        id: "diamond",
        icon: "icons/gem.svg",
        name: "Diamante",
        unlocked: true,
      });
    } else {
      badges.push({
        id: "diamond",
        icon: "icons/gem.svg",
        name: "Diamante",
        unlocked: false,
      });
    }

    // Badge: Rel√°mpago (50 d√≠as en total)
    if (stats.totalDays >= 50) {
      badges.push({
        id: "lightning",
        icon: "icons/zap.svg",
        name: "Rel√°mpago",
        unlocked: true,
      });
    } else {
      badges.push({
        id: "lightning",
        icon: "icons/zap.svg",
        name: "Rel√°mpago",
        unlocked: false,
      });
    }

    // Badge: Precisi√≥n (90% de √©xito mensual)
    if (monthSuccess >= 90) {
      badges.push({
        id: "target",
        icon: "icons/target-arrow.svg",
        name: "Precisi√≥n",
        unlocked: true,
      });
    } else {
      badges.push({
        id: "target",
        icon: "icons/target-arrow.svg",
        name: "Precisi√≥n",
        unlocked: false,
      });
    }

    // Badge: Campe√≥n (100 d√≠as en total)
    if (stats.totalDays >= 100) {
      badges.push({
        id: "trophy",
        icon: "icons/trophy.svg",
        name: "Campe√≥n",
        unlocked: true,
      });
    } else {
      badges.push({
        id: "trophy",
        icon: "icons/trophy.svg",
        name: "Campe√≥n",
        unlocked: false,
      });
    }

    // Badge: Estrella (180 d√≠as en total)
    if (stats.totalDays >= 180) {
      badges.push({
        id: "star",
        icon: "icons/star.svg",
        name: "Estrella",
        unlocked: true,
      });
    } else {
      badges.push({
        id: "star",
        icon: "icons/star.svg",
        name: "Estrella",
        unlocked: false,
      });
    }

    // Badge: Leyenda (365 d√≠as en total)
    if (stats.totalDays >= 365) {
      badges.push({
        id: "crown",
        icon: "icons/chess-queen.svg",
        name: "Leyenda",
        unlocked: true,
      });
    } else {
      badges.push({
        id: "crown",
        icon: "icons/chess-queen.svg",
        name: "Leyenda",
        unlocked: false,
      });
    }

    // Badge: Cohete (mejor racha personal > 20)
    if (stats.bestStreak >= 20) {
      badges.push({
        id: "rocket",
        icon: "icons/rocket.svg",
        name: "Cohete",
        unlocked: true,
      });
    } else {
      badges.push({
        id: "rocket",
        icon: "icons/rocket.svg",
        name: "Cohete",
        unlocked: false,
      });
    }

    // Badge: Consistencia (mejor racha > 28 d√≠as)
    if (stats.bestStreak >= 28) {
      badges.push({
        id: "muscle",
        icon: "icons/biceps-flexed.svg",
        name: "Consistencia",
        unlocked: true,
      });
    } else {
      badges.push({
        id: "muscle",
        icon: "icons/biceps-flexed.svg",
        name: "Consistencia",
        unlocked: false,
      });
    }

    // Badge: Artista (mes completo sin fallos - 30 d√≠as seguidos)
    if (stats.currentStreak >= 30 && monthSuccess >= 95) {
      badges.push({
        id: "art",
        icon: "icons/palette.svg",
        name: "Artista",
        unlocked: true,
      });
    } else {
      badges.push({
        id: "art",
        icon: "icons/palette.svg",
        name: "Artista",
        unlocked: false,
      });
    }

    return badges;
  }

  /**
   * Renderiza la cara trasera del card
   */
  renderCardBack(container, habit, basicStats, advancedStats) {
    if (!advancedStats) return;

    // Header del reverso
    const header = container.createDiv({ cls: "card-back-header" });
    const title = header.createDiv({ cls: "card-back-title" });
    title.innerHTML = `<span class="back-arrow">‚Üê</span> An√°lisis de Desempe√±o - ${habit.tema}`;

    const flipBtn = header.createDiv({ cls: "flip-button" });
    flipBtn.textContent = "";
    flipBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      const card = container.closest(".habit-card");
      if (card) card.classList.toggle("flipped");
    });

    // Contenedor de estad√≠sticas (4 columnas)
    const statsContainer = container.createDiv({ cls: "card-back-stats" });

    // Columna 1: Gr√°fico Donut
    const col1 = statsContainer.createDiv({ cls: "stat-column" });
    col1.createDiv({ cls: "stat-column-title", text: "√âxito Mensual" });
    this.renderDonutChart(col1, advancedStats.monthSuccess, habit.colors);

    // Columna 2: D√≠a m√°s productivo
    const col2 = statsContainer.createDiv({ cls: "stat-column" });
    col2.createDiv({ cls: "stat-column-title", text: "D√≠a M√°s Productivo" });

    const topDayDisplay = col2.createDiv({ cls: "top-day-display" });
    const topDayMain = topDayDisplay.createDiv({ cls: "top-day-main" });
    topDayMain.createDiv({ cls: "top-day-icon", text: "" });

    const topDayInfo = topDayMain.createDiv({ cls: "top-day-info" });
    topDayInfo.createDiv({ cls: "top-day-name", text: advancedStats.topDay });
    topDayInfo.createDiv({
      cls: "top-day-percent",
      text: `${advancedStats.topDayPercent}% de √©xito`,
    });

    // Mini gr√°fico de barras
    const weekBars = topDayDisplay.createDiv({ cls: "week-bars" });
    const dayNames = ["L", "M", "X", "J", "V", "S", "D"];
    for (let i = 0; i < 7; i++) {
      const dayData = advancedStats.dayStats.get(i);
      const percent =
        dayData.total > 0 ? (dayData.completed / dayData.total) * 100 : 0;
      const bar = weekBars.createDiv({ cls: "week-bar" });
      bar.style.height = `${Math.max(5, percent)}%`;
      if (dayNames[i] === advancedStats.topDay.charAt(0)) {
        bar.addClass("top");
      }
      bar.createDiv({ cls: "week-bar-label", text: dayNames[i] });
    }

    // Tendencia
    const trend = topDayDisplay.createDiv({ cls: "trend-indicator" });
    const trendArrow = trend.createSpan({
      cls: `trend-arrow ${advancedStats.trend}`,
    });
    if (advancedStats.trend === "up") trendArrow.textContent = "‚Üë";
    else if (advancedStats.trend === "down") trendArrow.textContent = "‚Üì";
    else trendArrow.textContent = "‚Üí";
    trend.createSpan({
      text:
        advancedStats.trend === "up"
          ? "Mejorando"
          : advancedStats.trend === "down"
            ? "Bajando"
            : "Estable",
    });

    // Columna 3: XP y Nivel
    const col3 = statsContainer.createDiv({ cls: "stat-column" });
    col3.createDiv({ cls: "stat-column-title", text: "Progreso" });

    const xpDisplay = col3.createDiv({ cls: "xp-display" });
    const levelBadge = xpDisplay.createDiv({ cls: "level-badge" });
    const levelIcon = levelBadge.createDiv({ cls: "level-icon" });
    const iconImg = levelIcon.createEl("img");

    const pluginPath = `.obsidian/plugins/ldr-grid-tracker/${advancedStats.levelIcon}`;
    iconImg.src = this.app.vault.adapter.getResourcePath(pluginPath);

    iconImg.alt = advancedStats.levelName;
    iconImg.addClass("level-icon-img");

    const levelInfo = levelBadge.createDiv({ cls: "level-info" });
    levelInfo.createDiv({
      cls: "level-number",
      text: `Nivel ${advancedStats.level}`,
    });
    levelInfo.createDiv({ cls: "level-name", text: advancedStats.levelName });

    const xpBarContainer = xpDisplay.createDiv({ cls: "xp-bar-container" });
    const xpBar = xpBarContainer.createDiv({ cls: "xp-bar" });
    const xpBarFill = xpBar.createDiv({ cls: "xp-bar-fill" });
    xpBarFill.style.width = `${advancedStats.percentToNext}%`;

    if (advancedStats.percentToNext >= 90) {
      xpBarFill.addClass("almost-level-up");
    }

    const xpNumbers = xpBarContainer.createDiv({ cls: "xp-numbers" });
    xpNumbers.createSpan({ text: `${advancedStats.xpInCurrentLevel} XP` });
    xpNumbers.createSpan({ text: `${advancedStats.xpNeededForLevel} XP` });

    xpBarContainer.createDiv({
      cls: "xp-to-next",
      text: `${advancedStats.xpNeededForLevel - advancedStats.xpInCurrentLevel} XP para subir`,
    });

    // Columna 4: Badges
    const col4 = statsContainer.createDiv({ cls: "stat-column" });
    col4.createDiv({ cls: "stat-column-title", text: "Logros" });

    const badgesDisplay = col4.createDiv({ cls: "badges-display" });
    const unlockedCount = advancedStats.badges.filter((b) => b.unlocked).length;
    badgesDisplay.createDiv({
      cls: "badges-count",
      text: `${unlockedCount}/${advancedStats.badges.length} desbloqueados`,
    });

    const badgesGrid = badgesDisplay.createDiv({ cls: "badges-grid" });

    for (const badge of advancedStats.badges) {
      const badgeItem = badgesGrid.createDiv({ cls: "badge-item" });

      // Crear imagen del icono
      const iconImg = badgeItem.createEl("img");

      const pluginPath = `.obsidian/plugins/ldr-grid-tracker/${badge.icon}`;
      iconImg.src = this.app.vault.adapter.getResourcePath(pluginPath);
      console.log("Badge icon path:", iconImg.src);

      iconImg.alt = "";
      iconImg.addClass("badge-icon");

      // Debug: Log para verificar la ruta
      console.log(`üìç Loading badge icon: ${iconImg.src}`);

      // Manejo de error si la imagen no carga
      iconImg.addEventListener("error", () => {
        console.error(`‚ùå Failed to load icon: ${badge.icon}`);
        // Fallback: ocultar imagen y mostrar emoji si existe
        iconImg.style.display = "none";
        if (badge.emoji) {
          badgeItem.textContent = badge.emoji;
        }
      });

      iconImg.addEventListener("load", () => {
        console.log(`‚úÖ Icon loaded successfully: ${badge.icon}`);
      });

      // Tooltip con el nombre del badge
      badgeItem.setAttribute("data-tooltip", badge.name);

      // Agregar clase seg√∫n estado
      if (badge.unlocked) {
        badgeItem.addClass("unlocked");
      } else {
        badgeItem.addClass("locked");
      }
    }
  }
  /**
   * Renderiza un gr√°fico de dona (donut chart)
   */
  renderDonutChart(container, percentage, colors) {
    const donutContainer = container.createDiv({ cls: "donut-container" });
    const canvas = donutContainer.createEl("canvas", { cls: "donut-chart" });
    const centerText = donutContainer.createDiv({ cls: "donut-center-text" });
    centerText.createDiv({ cls: "donut-percentage", text: `${percentage}%` });
    centerText.createDiv({ cls: "donut-label", text: "√âxito" });

    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    const size = 120;
    const dpr = window.devicePixelRatio || 1;
    canvas.width = size * dpr;
    canvas.height = size * dpr;
    canvas.style.width = `${size}px`;
    canvas.style.height = `${size}px`;
    ctx.scale(dpr, dpr);

    const centerX = size / 2;
    const centerY = size / 2;
    const radius = size / 2 - 10;
    const lineWidth = 16;

    // Fondo del c√≠rculo
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
    ctx.lineWidth = lineWidth;
    ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
    ctx.stroke();

    // Arco de progreso
    const endAngle = -Math.PI / 2 + (percentage / 100) * 2 * Math.PI;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, -Math.PI / 2, endAngle);
    ctx.lineWidth = lineWidth;

    // Color basado en porcentaje
    let color;
    if (percentage >= 80) {
      color = colors[4] || "#4ade80"; // Verde
    } else if (percentage >= 60) {
      color = colors[3] || "#fbbf24"; // Amarillo
    } else if (percentage >= 40) {
      color = colors[2] || "#f97316"; // Naranja
    } else {
      color = colors[1] || "#ef4444"; // Rojo
    }

    ctx.strokeStyle = color;
    ctx.lineCap = "round";
    ctx.stroke();
  }

  /**
   * Renderiza las estad√≠sticas del h√°bito (VERSI√ìN CORREGIDA)
   */
  renderStats(card, habit, stats) {
    const statsContainer = card.createDiv({ cls: "habit-stats" });
    const weeklyGoal = habit.metaSemanal || 7;

    // 1. Contenedor de la fila de progreso
    const weekProgress = statsContainer.createDiv({ cls: "stat-item" });

    // 2. Texto
    weekProgress.createSpan({
      text: `Esta semana: ${stats.thisWeek}/${weeklyGoal}`,
    });

    // 3. Barra de progreso
    const progressBar = weekProgress.createDiv({ cls: "progress-bar" });
    const progressFill = progressBar.createDiv({ cls: "progress-bar-fill" });

    // C√°lculo seguro del porcentaje (evita divisi√≥n por cero)
    const rawPercentage =
      weeklyGoal > 0 ? (stats.thisWeek / weeklyGoal) * 100 : 0;
    const percentage = Math.min(100, Math.max(0, rawPercentage));

    // Asignar ancho
    progressFill.style.width = `${percentage}%`;

    // 4. L√≥gica de color robusta
    // Intentamos usar el 3er color del h√°bito, o el √∫ltimo disponible, o verde por defecto.
    let colorToUse = "#40c463"; // Verde fallback
    if (
      habit.colors &&
      Array.isArray(habit.colors) &&
      habit.colors.length > 0
    ) {
      // Usamos un √≠ndice seguro
      const colorIndex = Math.min(habit.colors.length - 1, 3);
      colorToUse = habit.colors[colorIndex];
    }
    progressFill.style.backgroundColor = colorToUse;

    // Debug en consola para verificar (presiona Ctrl+Shift+I en Obsidian para ver esto)
    // console.log(`Barra para ${habit.tema}: ${percentage}% con color ${colorToUse}`);

    // Resto de estad√≠sticas
    const totalStat = statsContainer.createDiv({ cls: "stat-item" });
    totalStat.createSpan({ text: `Total: ${stats.totalDays} d√≠as` });

    const bestStreakStat = statsContainer.createDiv({ cls: "stat-item" });
    bestStreakStat.createSpan({
      text: `Mejor racha: ${stats.bestStreak} d√≠as`,
    });
  }
  /**
   * Muestra mensaje cuando no hay configuraci√≥n
   */
  renderNoConfig(container) {
    const message = container.createDiv({ cls: "habit-grid-message" });
    message.createEl("h2", { text: "\u2699\uFE0F Configuraci\xF3n necesaria" });
    message.createEl("p", {
      text: "Por favor, configura la ruta del archivo de h\xE1bitos en los ajustes del plugin.",
    });
    const button = message.createEl("button", { text: "Abrir ajustes" });
    button.onclick = () => {
      this.app.setting.open();
      this.app.setting.openTabById("habit-grid-tracker");
    };
  }
  /**
   * Muestra mensaje cuando el archivo no se encuentra
   */
  renderFileNotFound(container) {
    const message = container.createDiv({ cls: "habit-grid-message" });
    message.createEl("h2", { text: "\u{1F4C1} Archivo no encontrado" });
    message.createEl("p", {
      text: `No se encontr\xF3 el archivo: ${this.plugin.settings.configFilePath}`,
    });
  }
  /**
   * Muestra mensaje de error
   */
  renderError(container, error) {
    const message = container.createDiv({ cls: "habit-grid-message error" });
    message.createEl("h2", { text: "\u274C Error" });
    message.createEl("p", {
      text: `Error al cargar los datos: ${error.message}`,
    });
  }
  /**
   * Refresca la vista
   */
  async refresh() {
    await this.loadAndRender();
  }
};

// src/settings/SettingsTab.ts
var import_obsidian2 = require("obsidian");
var HabitGridSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.colorPickerValue = "#a78bfa";
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "LDR | Habit Grid Tracker" });
    containerEl.createEl("p", {
      text: "Configura tu plugin de seguimiento de h\xE1bitos.",
      cls: "setting-item-description",
    });
    containerEl.createEl("h2", { text: "Archivo de datos" });
    new import_obsidian2.Setting(containerEl)
      .setName("Ruta del archivo de h\xE1bitos")
      .setDesc(
        "Ruta al archivo Markdown que contiene las definiciones de h\xE1bitos y el TODO list. Ejemplo: _habits/2026.md",
      )
      .addText((text) =>
        text
          .setPlaceholder("_habits/2026.md")
          .setValue(this.plugin.settings.configFilePath)
          .onChange(async (value) => {
            this.plugin.settings.configFilePath = value;
            await this.plugin.saveSettings();
          }),
      );
    new import_obsidian2.Setting(containerEl)
      .setName("Imagen de banner")
      .setDesc(
        "Ruta a una imagen para usar como banner en la parte superior (opcional). Ejemplo: Assets/banner.png",
      )
      .addText((text) =>
        text
          .setPlaceholder("Assets/mi-banner.png")
          .setValue(this.plugin.settings.bannerImagePath)
          .onChange(async (value) => {
            this.plugin.settings.bannerImagePath = value;
            await this.plugin.saveSettings();
            this.plugin.refreshView();
          }),
      );
    containerEl.createEl("h2", { text: "Comportamiento" });
    new import_obsidian2.Setting(containerEl)
      .setName("Abrir al iniciar Obsidian")
      .setDesc(
        "Abre autom\xE1ticamente el Grid Tracker cuando inicias Obsidian",
      )
      .addToggle((toggle) =>
        toggle
          .setValue(this.plugin.settings.openOnStartup)
          .onChange(async (value) => {
            this.plugin.settings.openOnStartup = value;
            await this.plugin.saveSettings();
          }),
      );
    containerEl.createEl("h2", { text: "Visualizaci\xF3n" });
    new import_obsidian2.Setting(containerEl)
      .setName("Mostrar estad\xEDsticas")
      .setDesc(
        "Muestra estad\xEDsticas debajo de cada grid (racha, total, progreso semanal)",
      )
      .addToggle((toggle) =>
        toggle
          .setValue(this.plugin.settings.showStats)
          .onChange(async (value) => {
            this.plugin.settings.showStats = value;
            await this.plugin.saveSettings();
            this.plugin.refreshView();
          }),
      );
    new import_obsidian2.Setting(containerEl)
      .setName("La semana empieza en")
      .setDesc("D\xEDa en que comienza la semana para el grid")
      .addDropdown((dropdown) =>
        dropdown
          .addOption("monday", "Lunes")
          .addOption("sunday", "Domingo")
          .setValue(this.plugin.settings.weekStartsOn)
          .onChange(async (value) => {
            this.plugin.settings.weekStartsOn = value;
            await this.plugin.saveSettings();
            this.plugin.refreshView();
          }),
      );
    new import_obsidian2.Setting(containerEl)
      .setName("Tama\xF1o de celda")
      .setDesc("Tama\xF1o en p\xEDxeles de cada celda del grid")
      .addSlider((slider) =>
        slider
          .setLimits(8, 20, 1)
          .setValue(this.plugin.settings.gridCellSize)
          .setDynamicTooltip()
          .onChange(async (value) => {
            this.plugin.settings.gridCellSize = value;
            await this.plugin.saveSettings();
            this.plugin.refreshView();
          }),
      );
    new import_obsidian2.Setting(containerEl)
      .setName("Espacio entre celdas")
      .setDesc("Espacio en p\xEDxeles entre cada celda")
      .addSlider((slider) =>
        slider
          .setLimits(1, 6, 1)
          .setValue(this.plugin.settings.gridGap)
          .setDynamicTooltip()
          .onChange(async (value) => {
            this.plugin.settings.gridGap = value;
            await this.plugin.saveSettings();
            this.plugin.refreshView();
          }),
      );
    containerEl.createEl("h2", { text: "Generador de Paleta de Colores" });
    const colorGenContainer = containerEl.createDiv({
      cls: "color-generator-container",
    });
    const colorGenDesc = colorGenContainer.createEl("p", {
      text: "Selecciona un color base y se generar\xE1 una paleta de 5 colores para usar en tus h\xE1bitos.",
      cls: "setting-item-description",
    });
    const colorPickerRow = colorGenContainer.createDiv({
      attr: {
        style: "display: flex; align-items: center; gap: 12px; margin: 16px 0;",
      },
    });
    colorPickerRow.createSpan({ text: "Color base:" });
    const colorPicker = colorPickerRow.createEl("input", {
      type: "color",
      value: this.colorPickerValue,
    });
    colorPicker.style.cssText =
      "width: 60px; height: 36px; border: none; cursor: pointer; border-radius: 6px;";
    const previewContainer = colorGenContainer.createDiv({
      cls: "color-generator-preview",
    });
    const outputContainer = colorGenContainer.createDiv({
      cls: "color-generator-output",
    });
    const generatePalette = (hexColor) => {
      const colors = this.generateColorPalette(hexColor);
      previewContainer.empty();
      colors.forEach((color, index) => {
        const swatch = previewContainer.createDiv({
          cls: "color-generator-swatch",
        });
        swatch.style.backgroundColor = color;
        swatch.setAttribute("title", `Nivel ${index}: ${color}`);
      });
      const outputText = `colors: ["${colors.join('", "')}"]`;
      outputContainer.setText(outputText);
      outputContainer.setAttribute("title", "Click para copiar");
    };
    generatePalette(this.colorPickerValue);
    colorPicker.addEventListener("input", (e) => {
      const target = e.target;
      this.colorPickerValue = target.value;
      generatePalette(target.value);
    });
    outputContainer.addEventListener("click", async () => {
      const text = outputContainer.getText();
      await navigator.clipboard.writeText(text);
      const originalText = outputContainer.getText();
      outputContainer.setText("\xA1Copiado!");
      outputContainer.style.background = "rgba(74, 222, 128, 0.2)";
      setTimeout(() => {
        outputContainer.setText(originalText);
        outputContainer.style.background = "";
      }, 1500);
    });
    containerEl.createEl("h2", { text: "Ayuda" });
    const helpSection = containerEl.createDiv({ cls: "setting-item" });
    const helpDesc = helpSection.createDiv({ cls: "setting-item-description" });
    helpDesc.createEl("h3", { text: "Formato del archivo de h\xE1bitos:" });
    const codeExample = helpDesc.createEl("pre");
    codeExample.createEl("code", {
      text: `# Grids

\`\`\`habit-definition
tema: estudio
emoji: Assets/icons/book.png
colors: ["#ebedf0", "#c4b5fd", "#a78bfa", "#8b5cf6", "#7c3aed"]
meta_semanal: 5
descripcion: Estudiar al menos 1 hora
\`\`\`

# TODO list

## 01/01/2026
- [x] estudio

## 02/01/2026
- [x] estudio`,
    });
    helpDesc.createEl("h4", { text: "Opciones para el campo emoji/icono:" });
    helpDesc.createEl("p", {
      text: "\u2022 Emoji: \u{1F4DA} (copiar y pegar emoji)",
    });
    helpDesc.createEl("p", {
      text: "\u2022 Icono local: Assets/icons/mi-icono.png",
    });
    helpDesc.createEl("p", {
      text: "\u2022 URL externa: https://ejemplo.com/icono.svg",
    });
    helpDesc.createEl("p", {
      text: "\u2022 Vac\xEDo: (sin icono, solo el nombre)",
    });
  }
  /**
   * Genera una paleta de 5 colores basada en un color central
   */
  generateColorPalette(hexColor) {
    const rgb = this.hexToRgb(hexColor);
    const hsl = this.rgbToHsl(rgb.r, rgb.g, rgb.b);
    const colors = [];
    colors.push("#ebedf0");
    colors.push(
      this.hslToHex(hsl.h, hsl.s * 0.6, Math.min(0.85, hsl.l + 0.25)),
    );
    colors.push(hexColor);
    colors.push(
      this.hslToHex(
        hsl.h,
        Math.min(1, hsl.s * 1.1),
        Math.max(0.25, hsl.l - 0.15),
      ),
    );
    colors.push(
      this.hslToHex(
        hsl.h,
        Math.min(1, hsl.s * 1.2),
        Math.max(0.15, hsl.l - 0.3),
      ),
    );
    return colors;
  }
  hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result
      ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16),
        }
      : { r: 0, g: 0, b: 0 };
  }
  rgbToHsl(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;
    const max = Math.max(r, g, b),
      min = Math.min(r, g, b);
    let h = 0,
      s = 0;
    const l = (max + min) / 2;
    if (max !== min) {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
          break;
        case g:
          h = ((b - r) / d + 2) / 6;
          break;
        case b:
          h = ((r - g) / d + 4) / 6;
          break;
      }
    }
    return { h, s, l };
  }
  hslToHex(h, s, l) {
    let r, g, b;
    if (s === 0) {
      r = g = b = l;
    } else {
      const hue2rgb = (p2, q2, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;
        if (t < 1 / 2) return q2;
        if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
        return p2;
      };
      const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      const p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }
    const toHex = (x) => {
      const hex = Math.round(x * 255).toString(16);
      return hex.length === 1 ? "0" + hex : hex;
    };
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
  }
};

// src/main.ts
var HabitGridPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    console.log("Loading Habit Grid Tracker plugin");
    await this.loadSettings();
    this.parser = new HabitParser();
    this.registerView(
      HABIT_GRID_VIEW_TYPE,
      (leaf) => new HabitGridView(leaf, this),
    );
    this.addRibbonIcon("calendar-check", "Habit Grid Tracker", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-habit-grid-view",
      name: "Abrir vista de Habit Grid",
      callback: () => {
        this.activateView();
      },
    });
    this.addCommand({
      id: "open-habit-grid-view-sidebar",
      name: "Abrir Habit Grid en panel lateral",
      callback: () => {
        this.activateViewInSidebar();
      },
    });
    this.addCommand({
      id: "refresh-habit-grid",
      name: "Refrescar datos de h\xE1bitos",
      callback: () => {
        this.refreshView();
      },
    });
    this.addSettingTab(new HabitGridSettingTab(this.app, this));
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (
          file instanceof import_obsidian3.TFile &&
          file.path === this.settings.configFilePath
        ) {
          this.refreshView();
        }
      }),
    );
    if (this.settings.openOnStartup) {
      this.app.workspace.onLayoutReady(() => {
        setTimeout(() => {
          this.activateView();
        }, 500);
      });
    }
    console.log("Habit Grid Tracker plugin loaded successfully");
  }
  onunload() {
    console.log("Unloading Habit Grid Tracker plugin");
  }
  /**
   * Carga los settings guardados
   */
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  /**
   * Guarda los settings
   */
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * Activa la vista del plugin en el panel CENTRAL (como tab normal)
   */
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(HABIT_GRID_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getLeaf("tab");
      if (leaf) {
        await leaf.setViewState({
          type: HABIT_GRID_VIEW_TYPE,
          active: true,
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  /**
   * Activa la vista del plugin en el panel lateral derecho
   */
  async activateViewInSidebar() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(HABIT_GRID_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({
          type: HABIT_GRID_VIEW_TYPE,
          active: true,
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  /**
   * Refresca la vista si est√° abierta
   */
  refreshView() {
    const leaves = this.app.workspace.getLeavesOfType(HABIT_GRID_VIEW_TYPE);
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view instanceof HabitGridView) {
        view.refresh();
      }
    }
  }
};
